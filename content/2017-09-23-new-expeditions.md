+++
title = "New Expeditions"
description = "For quite some time now  I’ve been searching for the perfect programming language for my next hobby project. As a matter of fact, there are two projects that I am considering at the moment, but given the levels of my procrastination and the ever-changing industry loop, the day of my initial commit for both projects seems blurred like never before."
[taxonomies]
tags = ["programming"]
[extra]
+++

![New Expeditions](../new_expeditions.jpg "New Expeditions image")

For quite some time now  I’ve been searching for the perfect programming language for my next hobby project. As a matter of fact, there are two projects that I am considering at the moment, but given the levels of my procrastination and the ever-changing industry loop, the day of my initial commit for both projects seems blurred like never before.

The common mistake I usually make is that before I start any project I do a lot of research, and from time to time I get stuck at the early stage – choosing the tech for my projct. Is it the fault of many choices we have these days, or is it some indecisive part of my personality? Or could it be due to the never ending options we have as developers? In order to answer these questions, firstly I need to define what is necessary for my project. I believe that my projects can’t live without the following thing:

1. **Portability**
2. **Good memory management**
3. **Speed**
4. **Ease-of-use**
5. **Modern approach**

##  The Programming Language Standard

While doing the research for the project, with the list in mind, I found myself actually searching for “the new programming language standard”. By that I mean **C++** of the new era, and not necessarily “the industry standard”. I know there is no such thing as a perfect programming language suitable for every project (nor there should be one). Sure, we can make **Ruby** do graphics or make web framework for **Cobol**, but is it really an optimal solution? Some languages are created for solving problems that their creators had in mind while creating them, some are created as multi-purposed tool that community shaped into a great solution for solving one thing only, while others are considered to be the ultimate languages or, as I like to call them: “programming languages standard”.

As a CS graduate and a **C** and **Assembly** enthusiast, I find **C++** very attractive. It does a lot of things for you while still being low-level enough. But then again, which **C++** am I referring to? Am I attracted to **ISO/IEC 14882** or **Visual C++** or **TurboC++**? What flavor is my favorite? That is my problem with **C++** actually. After years of doing projects in **C++** at university and considering it as the ultimate language, once I was out of university I realized it was just one flavor that we've studied, and that flavor is not commonly used anymore. Not that it would affect my project if I decide to use **C++98**, but it affects the time I invested in mastering the language and it affects the project in that ease-of-use part. In my humble opinion, **C++** these days, or at least ISO, became everything and nothing. Today one can refer to **C++** as computing. **C++** actually is computers. Our OSes are written in it or at least use it in some way or another, internet is full of applications that use it, and it is generally all around us. Moreover, there is one special thing that **C++** did to me that no other language could. After 3 years of doing projects at university using **C++**, I found myself actually not knowing how to write good **C++** code. Maybe it is the university that I should blame, for not providing us with good practices in **C++**, or maybe it is just me that used it in the wrong way the entire time. In any case, I disagree with **C++** being my weapon of choice for now. You may ask then, why not choose **C** instead of **C++** ? **C** is: fast, it doesn't change as much anymore, it was, and in some ways it still is, “the ultimate language”. Well, **C** doesn’t go under “modern” category. That category is there only because I find hobby projects useful for learning new tech and CS things, not necessarily to benefit from every project, but to somehow <em>“stay in the new tech loop”</em>.

##  New Horizons

I am not the first nor the last person in the industry that has these kind of issues. If we look around there are a lot of new “still in alpha” programming languages that are promising exactly the things that I am looking for. For instance, language like **Crystal**  claims to be <em>“fast as **C**,  slick as **Ruby**”</em>, **Nim** – the language that has “unparalleled performance in an elegant package” etc. All of these language seem fine, but were designed for specific field in mind, unlike their older brothers – **C**, **C++** or **Python**.

><em>Does software have some kind of independent inertia, where once CPUs really stop getting fast, software is just gonna keep going and just keep getting slower and slower until it is tolerable?</em>

><em>**Jonathan Blow**</em>

While being in that loop of <em>“upcoming”</em> programing languages I remembered Jonathan Blow, the mind behind Braid and The Witness. He has been on a journey to create “new programing standard” since 2014, and honestly, it is going in the right direction. His new programming language, seemingly called **Jai**, is still in development and unavailable for public. He is occasionally streaming development of the language and it’s integration in his game and non-game projects. Judging by his talk from this years Reboot Developers Conference, I must say that it seems very promising. My main problem regarding **Jai** is that its release date is still unknown. Could be tomorrow or in a year or two.

{{ youtube(id="De0Am_QcZiQ") }}

Being a passionate supporter of Handmade Community I came across a new “programming language standard” attempt which is claiming to solve exactly the problems I have. And that solution is called [**Odin**](https://github.com/gingerBill/Odin). Oh man, I was so hyped while I was reading about it, I think I even watched the presentation video more times just to have a good grasp of what the language actually has to offer. Once the hype wore off and rational thoughts came in, I realized that it is still in alpha and that its roadmap
still consists of some mandatory things that none of the modern languages can survive without. And sadly, that was the end of my **Odin** short story.

## Good Stuff

While I don’t have time for Jonathan Blow’s child to grow up nor enough courage to explore a language that is still in alpha stages, I came to conclusion that the language I want for this project is something that has ease-of-use like Ruby, portability like C, good memory management like **Python** and speed of **C++**. After quite some time (months of daily reading the Reddit and Hacker News), I stumbled upon three things: **Clojure**, **Rust** or **Go**.  **Lua** was also on the list, but in the process of searching I decided to limit myself to 00’s languages only.

Let’s start with the first from the list. **Clojure** is the oddest language from the list. It is based on **Lisp** , it uses **JVM** and for some reason computer graphics engineers started using it like crazy. Reason for that could be the fact that it is really fast and that it has its part in that “functional language paradigm hype train”. As its creator said in his conclusion on the official website:

><em>I hope you find Clojure's combination of facilities elegant, powerful, practical and fun to use.</em> 

><em>**Rich Hickey**</em>

I really like **Clojure** for all the things it does and the power of functional paradigm it has, but I got a little bit tired of all the brackets in its syntax, and that never clicked with me. I never felt fluent in reading it, and to be honest, I didn’t give it more time to sink in. I couldn't afford to spend more time on it.

Next on the list was **Rust**. **Rust** is, simply put, amazing! It is blazingly fast, modern, and it has awesome support from community. For some people it is considered to be “the new programming language standard” or the exchange for **C++**. For me… well… I did put it on “the chosen language” list, but I wanted to check one more language before I decide. And that final language was **Go**.

**Go** is modern **C**. Heck even one of its core designers is one of the makers of **C**, Ken Thompson. Without any further ado I started my expedition in **Go**. Hours and days passed and I was totally hooked. I even started bragging in the office how **Go** is the ultimate language of choice that every modern software should be built upon. It is so easy to use and it has everything that my list proposed. Maybe it isn’t as easy on syntax as Ruby is, but after only few hours of working in it I was feeling right at home. That sadly didn’t happen with **Clojure**.

So it was time to decide, should I use **Rust** or should I use **Go**? I chose **Go**. I don't know exactly why I chose **Go** over **Rust**, and demands that my projects have are satisfied by both. I think I chose **Go** simply because I felt that my projects will benefit more from it based on my previously proposed list of features. Or will they?